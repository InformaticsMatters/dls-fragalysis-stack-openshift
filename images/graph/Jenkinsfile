#!groovyâ€‹

// The Fragalysis Graph Database Builder.

pipeline {

  agent { label 'buildah-slave' }

  environment {
    // Registry details
    REGISTRIY_USER = 'jenkins'
    REGISTRY = 'docker-registry.default:5000'
    STREAM_IMAGE = "${REGISTRY}/fragalysis-cicd/graph-stream:latest"

    // get_unbuilt_data_dirtectory environment...
    SOURCE_DATA_ROOT = '/fragalysis/graph_data'
    TARGET_IMAGE = 'fragalysis-cicd/graph-stream'
    INSIST_ON_READY = 'Yes'
    READY_FILE = 'READY'
    HOURLY_DATA = 'No'
    FORCE_BUILD = 'No'

    // Always push the image (whether it's new or not)
    ALWAYS_PUSH = 'No'

    // Slack channel for all notifictions
    SLACK_CICD_CHANNEL = 'dls-cicd-graphimage'
    // Slack channel to be used for errors/failures
    // (which also go to the CI/CD channel)
    SLACK_ALERT_CHANNEL = 'dls-alerts'
  }

  stages {

    stage('Inspect') {
      steps {
        dir('images') {
          // - Get the registry user API token (used in the Python module)
          // - Run the get_unbuilt_data_directory  module
          // - Print the script log.
          sh "ls ${env.SOURCE_DATA_ROOT}"
          script {
            env.REGISTRY_USER_TOKEN = sh(script: 'oc whoami -t', returnStdout: true).trim()
            DATA_ORIGIN = sh(script: './get_unbuilt_data_directory.py', returnStdout: true).trim()
          }
          sh 'cat get_unbuilt_data_directory.log'
        }
      }
    }

    stage('Build Image') {
      when {
        expression { DATA_ORIGIN.length() > 0 }
      }
      steps {
        script {
          TOKEN = sh(script: 'oc whoami -t', returnStdout: true).trim()
        }
        dir('images/graph') {
          sh "cp ${SOURCE_DATA_ROOT}/${DATA_ORIGIN}/* data-loader"
          sh "buildah bud --tls-verify=false --creds=${env.REGISTRY_USER}:${TOKEN} --format docker --build-arg DATA_ORIGIN=${DATA_ORIGIN} -f Dockerfile -t ${env.STREAM_IMAGE} ."
        }
      }
    }

    stage('Skip Image') {
      when {
        expression { DATA_ORIGIN.length() == 0 && ALWAYS_PUSH == 'No' }
      }
      steps {
        slackSend channel: "#${env.SLACK_CICD_CHANNEL}",
                  color: 'warning',
                  message: "Graph image build ${env.BUILD_NUMBER} - no new data, skipping"
      }
    }

    stage('Push Image') {
      when {
        expression { DATA_ORIGIN.length() > 0 || ALWAYS_PUSH == 'Yes' }
      }
      steps {
        script {
          TOKEN = sh(script: 'oc whoami -t', returnStdout: true).trim()
        }
        sh "podman login --tls-verify=false --username ${env.REGISTRY_USER} --password ${TOKEN} ${env.REGISTRY}"
        sh "buildah push --tls-verify=false ${env.STREAM_IMAGE} docker://${env.STREAM_IMAGE}"
        sh "podman logout ${env.REGISTRY}"
        sh "buildah images"
        slackSend channel: "#${env.SLACK_CICD_CHANNEL}",
                  color: 'good',
                  message: "Graph image build ${env.BUILD_NUMBER} - new image for '${DATA_ORIGIN}' data has been pushed"
      }
    }

  }

  // Post-job actions.
  // See https://jenkins.io/doc/book/pipeline/syntax/#post
  post {

    failure {

      ERR_MSG = "Graph image build ${env.BUILD_NUMBER} - failed (${env.BUILD_URL})"
      slackSend channel: "#${SLACK_CICD_CHANNEL}",
                color: 'danger',
                message: $ERR_MSG
      slackSend channel: "#${SLACK_ALERT_CHANNEL}",
                color: 'danger',
                message: $ERR_MSG

    }

  }

}
